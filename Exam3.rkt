#lang lsl

;; Problem 0:
;;
;; We gave you a UNIQUE code when you walked in the door. Please fill
;; in the string below with your code, and be sure you include this
;; definition along with the rest of your code. This confirms that you
;; were at the exam, as required.

(define CODE "88927")


;; Problem 1
;;
;; Consider the following function, whose definition is not provided, but which
;; is supposed to transform the _contents_ of a cell (add to the number, subtract,
;; etc) and return a new cell with the changed contents.

(define-struct cell (contents))

(: transform-cell (-> (Cell Integer) (Cell Integer)))
(define (transform-cell c) (raise 'not-provided)) ;; def not provided 

;; Your task is to write a specification that ensures:
;; 1. That the function returns a _new_ cell, not the one that was passed to it.
;; 2. That the cell that is passed as an argument is not mutated. i.e., after calling the
;;    function, it should have the same contents.

(: transform-cell-prop (-> (Cell Integer) True))
(define (transform-cell-prop c)
  (let* ([start-val (cell-contents c)]
         [return-cell (transform-cell c)])
    (and (not (eq? c return-cell))
         (equal? (cell-contents c) ;; after calling the function
                 start-val)))) ;; before calling the function

;; Problem 2
;;
;; Consider the following two functions `function-1` and `function-2`.
;;
;; While the specification, `function-prop`, seems to indicate that they behave
;; the same, since it passes `check-contract`, we have reason to believe
;; otherwise; by inspection of the code, you should believe this as well.
;;
;; Your task is to write a zero-argument function called `generate-inputs` that
;; generates input (random or not) that, if passed to `function-prop`, will
;; cause it to return `#f` (and thus fail) at least some of the time. i.e., your
;; inputs will distinguish the two functions in a way that the default input
;; generated by `check-contract` has not. If your inputs are random (it is not
;; required to be), be sure that within a few calls (say, 10 or 20) it will
;; generate one that produces different results.


(: function-1 (-> (List Integer) Integer))
(define (function-1 lon)
  (let* ([ns (filter (lambda (n) (= n 0)) lon)] ;; the zeros??
         [l (length ns)]) ;; the number of zeros 
    (cond [(< l 10) 0] ;; less than 10 zeros -> 0
          [else (+ l 1)]))) ;; length + 1

(: function-2 (-> (List Integer) Integer))
(define (function-2 lon)
  (let* ([ns (filter (lambda (n) (= n 0)) lon)]
         [l (length ns)])
    (cond [(< l 10) 0] ;; less than 10 zeros -> 0
          [else (+ l 2)]))) ;; length + 2


(: function-prop (-> (List Integer) True)) ;; inspect the code fun 1 and 2 arent 
(define (function-prop l)
  (equal? (function-1 l) (function-2 l))) ;; behaving the same 

(: generate-inputs (-> (List Integer)))
(define (generate-inputs)
  ;; generates input, when passed to function prop will make it #f
  ;; generate at least 10 zeros to break the list of integers
  (build-list 20 (Î» (_) (random 2))))
;; Problem 3
;;
;; Consider a function, `give-mortgage?` with signature `(-> Person~
;; Boolean)` which takes, as input, the following data:
;;
(define-struct person (name age race income zipcode))
(define-contract Person~ (Person String Natural String Natural String))


;; The function is not provided, but its purpose is to determine whether to give
;; a mortgage (i.e., loan to buy a house) to the given person.

(: give-mortgage? (-> Person~ Boolean))
(define (give-mortgage? p)
  (raise 'not-provided)) ;; should this person get a mortgage?

;; Mortgage lending is known to suffer from bias: i.e., people are less likely
;; to be given a mortgage based on demographic information unrelated to their
;; financial likelihood of repaying it (e.g., their race, gender, age).
;;
;; Even more insidiously, machine learning models that power many of these
;; systems currently can easily "learn" one form of information from another --
;; e.g., due to historic housing segregation, zipcode is often a proxy for race,
;; and people have done experiments with job applications that show that names
;; alone are often used to screen people out, unrelated to any other aspects of
;; the applicant.
;;
;; Of course, certain attributes _are_ important for determining the liklihood
;; of repaying a loan, which is the task that such a function must perform:
;; loans cannot (responsibly) be given out without some process, or randomly. Of
;; the (limited) information we have above, income is relevant, but also
;; age could impact decisions in reasonable ways.
;;
;; Your task, in this problem, is to design a specification,
;; `give-mortgage?-fair`, that ensures that `give-mortgage?` does not suffer
;; from this bias -- i.e.,

;; it does not produce different results for people who
;; have the same income/age but differ in other aspects.

;; It should take two
;; arbitrary `Person~`s and determine if `give-mortgage?`, applied to those, is
;; behaving in a fair manner.

(: give-mortgage?-fair (-> Person~ Person~ True))
(define (give-mortgage?-fair p1 p2)
  (let* ([p1? (give-mortgage? p1)] ; person 1 decision
         [p2? (give-mortgage? p2)] ; person 2 decision
         [income (- (person-income p1) 
                    (person-income p2))] ;; income difference 
         [age (- (person-age p1)
                 (person-age p2))]) ;; age difference
    (cond [(and p1? p2?
           (and
            (zero? income)
            (zero? age))) #t];;if they both get loans then should should have the same income and age 
          [(and p1? (not p2?)) (and (> (person-income p1)
                                       (person-income p2))
                                    (> (person-age p1)
                                       (person-age p2)))]
          [(and p2? (not p1?)) (and (> (person-income p2)
                                       (person-income p1))
                                    (< (person-age p1)
                                       (person-age p2)))]
          [else (and (not p1?)
                     (not p2?))]))) ;; not considering any other factor but income and age